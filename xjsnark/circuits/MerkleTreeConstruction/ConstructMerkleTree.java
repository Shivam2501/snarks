package xjsnark.merkleTreeConstruction;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.auxTypes.UnsignedInteger;
import backend.eval.CircuitEvaluator;

public class ConstructMerkleTree extends CircuitGenerator {



  public static void main(String[] args) {
    Config.multivariateExpressionMinimization = true;

    Config.arithOptimizerNumThreads = 4;
    Config.arithOptimizerTimeoutPerProblemMilliSec = 20000;

    new ConstructMerkleTree();
  }

  public ConstructMerkleTree() {
    super("ConstructMerkleTree");
    __generateCircuit();

  }



  public void __init() {
    input = new Input();
  }

  private Input input;
  private UnsignedInteger[] root;

  public static final int NUM_LEAF = 2;
  @Override
  public void __defineInputs() {
    super.__defineInputs();







  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();
    UnsignedInteger.makeOutput(this, root);







  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();






    input.__makeVerifiedWitness();




  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();









  }
  public void outsource() {
    UnsignedInteger[][] hashTree = new UnsignedInteger[NUM_LEAF * 2 - 1][];

    for (int i = 0; i < NUM_LEAF; i++) {
      hashTree[i + NUM_LEAF - 1] = Util.sha2(input.nodes[i]);
    }

    for (int i = NUM_LEAF - 2; i >= 0; i--) {
      hashTree[i] = Util.sha2(Util.concat(hashTree[i * 2 + 1], hashTree[i * 2 + 2]));
    }

    root = hashTree[0];
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
