package xjsnark.battleship;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.auxTypes.UnsignedInteger;
import java.math.BigInteger;
import backend.auxTypes.Bit;
import backend.auxTypes.ConditionalScopeTracker;
import backend.eval.CircuitEvaluator;

public class Battleship extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    Config.multivariateExpressionMinimization = true;

    // Num of threads could be set higher based on the machine specs. Setting it too high will lead to faster timeouts 
    Config.arithOptimizerNumThreads = 1;
    Config.arithOptimizerTimeoutPerProblemMilliSec = 20000;
    new Battleship();
  }

  public Battleship() {
    super("Battleship");
    __generateCircuit();

  }



  public void __init() {
    root = new Node();
    commit = new Commit();
    proof = new MerklePath();
    ship = new UnsignedInteger(8, new BigInteger("0"));
  }

  private Node root;
  private Commit commit;
  private MerklePath proof;
  private UnsignedInteger ship;

  public static final int HEIGHT = 8;
  @Override
  public void __defineInputs() {
    super.__defineInputs();





    root.__makeInput();
    commit.__makeInput();


  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();
    UnsignedInteger.makeOutput(this, ship);







  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();






    proof.__makeVerifiedWitness();




  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();









  }
  public void outsource() {

    Bit[] directionBits = proof.directionSelector.getBitElements();
    UnsignedInteger[] inputToNextHash = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 32);

    Node currentNode = commitVal(commit);
    for (int i = 0; i < HEIGHT; i++) {
      for (int j = 0; j < 16; j++) {
        {
          Bit bit_a0a0f0r = directionBits[i].copy();
          boolean c_a0a0f0r = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0f0r);
          if (c_a0a0f0r) {
            if (bit_a0a0f0r.getConstantValue()) {
              inputToNextHash[j].assign((j >= 8 ? currentNode.array[j - 8] : proof.nodes[i].array[j]), 32);
            } else {
              inputToNextHash[j].assign((j < 8 ? currentNode.array[j] : proof.nodes[i].array[j - 8]), 32);

            }
          } else {
            ConditionalScopeTracker.pushMain();
            ConditionalScopeTracker.push(bit_a0a0f0r);
            inputToNextHash[j].assign((j >= 8 ? currentNode.array[j - 8] : proof.nodes[i].array[j]), 32);

            ConditionalScopeTracker.pop();

            ConditionalScopeTracker.push(new Bit(true));

            inputToNextHash[j].assign((j < 8 ? currentNode.array[j] : proof.nodes[i].array[j - 8]), 32);
            ConditionalScopeTracker.pop();
            ConditionalScopeTracker.popMain();
          }

        }
      }
      currentNode = Util.sha2(inputToNextHash);
    }

    currentNode.assertEqual(root);

    ship.assign(commit.ship, 8);
  }
  private Node commitVal(Commit commit) {
    UnsignedInteger[] input = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 32);
    for (int i = 0; i < 13; i++) {
      input[i].assign(new UnsignedInteger(32, new BigInteger("0")), 32);
    }
    input[13].assign(UnsignedInteger.instantiateFrom(32, commit.row), 32);
    input[14].assign(UnsignedInteger.instantiateFrom(32, commit.column), 32);
    input[15].assign(UnsignedInteger.instantiateFrom(32, commit.ship), 32);

    return Util.sha2(input);
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
